import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np

def draw_pitch(ax):
    """
    Draws a minimalist, frameless horizontal soccer pitch on a given axes object.
    """
    WIDTH_SCALE = 68 / 105
    x_min, x_max = -1, 1
    y_min, y_max = -1 * WIDTH_SCALE, 1 * WIDTH_SCALE

    ax.set_xlim(x_min, x_max)
    ax.set_ylim(y_min, y_max)
    ax.set_aspect('equal', adjustable='box')
    ax.axis('off') # Turn off axis lines and labels

    # Pitch background and outer lines
    ax.add_patch(patches.Rectangle((x_min, y_min), 2, y_max - y_min, facecolor='#f4f4f4', edgecolor='black', zorder=0))
    ax.plot([0, 0], [y_min, y_max], color='black', linewidth=1, zorder=1)

    # Center circle
    center_circle = patches.Circle((0, 0), radius=0.174, edgecolor='black', facecolor='none', linewidth=1, zorder=1)
    ax.add_patch(center_circle)

    # Penalty areas
    pa_width = (40.3 / 68) * (y_max - y_min)
    pa_depth = (16.5 / 105) * (x_max - x_min)
    ax.add_patch(patches.Rectangle((x_max - pa_depth, -pa_width / 2), pa_depth, pa_width, edgecolor='black', facecolor='none', linewidth=1, zorder=1))
    ax.add_patch(patches.Rectangle((x_min, -pa_width / 2), pa_depth, pa_width, edgecolor='black', facecolor='none', linewidth=1, zorder=1))
    
    # Goal areas
    ga_width = (18.32 / 68) * (y_max - y_min)
    ga_depth = (5.5 / 105) * (x_max - x_min)
    ax.add_patch(patches.Rectangle((x_max - ga_depth, -ga_width / 2), ga_depth, ga_width, edgecolor='black', facecolor='none', linewidth=1, zorder=1))
    ax.add_patch(patches.Rectangle((x_min, -ga_width / 2), ga_depth, ga_width, edgecolor='black', facecolor='none', linewidth=1, zorder=1))

    # Penalty spots
    penalty_spot_dist = (11 / 105) * 2
    ax.add_patch(patches.Circle((x_max - penalty_spot_dist, 0), 0.01, color='black', zorder=1))
    ax.add_patch(patches.Circle((x_min + penalty_spot_dist, 0), 0.01, color='black', zorder=1))

def format_player_name(full_name):
    """
    Formats a full name to 'FirstInitial. LastName'.
    E.g., 'Juan Andres Meli' -> 'J. Meli'
    """
    if not isinstance(full_name, str):
        return str(full_name)
    
    parts = full_name.split()
    if not parts:
        return ""
        
    first_initial = parts[0][0]
    last_name = parts[-1] 
    
    return f"{first_initial}. {last_name}"

def visualize_combined_passes(csv_file, team_name=None, top_n=10):
    """
    FINAL FIX: Loads correct pass data.
    Normalization now occurs *per half* and is *anchored*
    to the goalkeeper's position for robustness.
    """
    try:
        df = pd.read_csv(csv_file)
    except FileNotFoundError:
        print(f"Error: The file '{csv_file}' was not found.")
        return

    # --- FIX: Convert coordinate columns to numeric ---
    coord_cols = ['x1', 'y1', 'x2', 'y2']
    for col in coord_cols:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    
    # Also ensure minute is numeric for half calculation
    df['minute'] = pd.to_numeric(df['minute'], errors='coerce')

    # Filter for correct passes
    df = df[df['event_type'] == 'correctPasses'].copy() 

    if team_name:
        df_team = df[df['team_name'] == team_name].copy()
        if df_team.empty:
            print(f"No correct passes found for team: {team_name}")
            return
    else:
        df_team = df.copy()

    # --- START ROBUST LOGIC: NORMALIZE ATTACKING DIRECTION PER HALF (GK-ANCHORED) ---
    
    # 1. Create a 'half' column
    df_team['half'] = np.where(df_team['minute'] < 45, 1, 2)
    
    games = df_team['Rival'].unique()
    goalkeeper_name = 'Ignacio Arce' # Using your suggestion
    normalized_dfs = []

    # 2. Group by game ('Rival') AND 'half'
    for game in games:
        for half in [1, 2]:
            game_half_df = df_team[
                (df_team['Rival'] == game) & (df_team['half'] == half)
            ].copy()
            
            if game_half_df.empty:
                continue
            
            # 3. Heuristic: Determine attacking direction for this half
            flip_this_half = False
            
            # 3a. Try to use Goalkeeper position as the anchor
            gk_passes_df = game_half_df[game_half_df['player_name'] == goalkeeper_name]['x1'].dropna()
            
            if not gk_passes_df.empty:
                avg_gk_x1 = gk_passes_df.mean()
                if avg_gk_x1 < 0:
                    # GK is in the left half, so team is attacking L->R. We must flip.
                    flip_this_half = True
                # If avg_gk_x1 > 0, GK is in right half, attacking R->L. No flip needed.
                
            else:
                # 3b. Fallback: No GK passes found, use all-pass average
                avg_all_x1 = game_half_df['x1'].dropna().mean()
                
                if pd.isna(avg_all_x1):
                    continue # No valid passes in this half
                    
                if avg_all_x1 < 0:
                    # Average position is in left half, attacking L->R. We must flip.
                    flip_this_half = True
            
            # 4. Apply flip if needed
            if flip_this_half:
                game_half_df[['x1', 'y1', 'x2', 'y2']] *= -1
            
            # 5. Append the (potentially flipped) half-game DF
            normalized_dfs.append(game_half_df)

    if not normalized_dfs:
        print("No data to plot after processing games.")
        return
        
    base_df = pd.concat(normalized_dfs)
    # --- END ROBUST NORMALIZATION LOGIC ---


    intervals = [(0, 15), (15, 30), (30, 45), (45, 60), (60, 75), (75, 999)]

    # Define a color palette for the top N combinations
    colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', 
              '#ffff33', '#a65628', '#f781bf', '#999999']

    fig, axes = plt.subplots(2, 3, figsize=(20, 14))
    fig.patch.set_facecolor('#f4f4f4')
    axes_flat = axes.flatten()

    for i, (start_min, end_min) in enumerate(intervals):
        ax = axes_flat[i]
        
        interval_df = base_df[
            (base_df['minute'] >= start_min) & (base_df['minute'] < end_min)
        ].copy()

        end_min_label = f"{end_min}" if end_min != 999 else "90+"
        interval_label = f"{start_min}-{end_min_label} min"

        draw_pitch(ax)
        
        ax.set_title(interval_label, loc='left', fontsize=14, fontweight='bold')

        if interval_df.empty:
            ax.text(0, 0, "No passes in this interval", 
                    ha='center', va='center', fontsize=12, family='monospace',
                    transform=ax.transData)
            continue

        # Drop rows missing data needed for plotting
        interval_df.dropna(subset=['player_name', 'receiver_name', 'x1', 'y1', 'x2', 'y2'], inplace=True)
        
        if interval_df.empty:
             ax.text(0, 0, "No valid passes in this interval", 
                    ha='center', va='center', fontsize=12, family='monospace',
                    transform=ax.transData)
             continue

        pass_combinations = interval_df.groupby(['player_name', 'receiver_name']).size().reset_index(name='pass_count')
        top_combinations = pass_combinations.sort_values(by='pass_count', ascending=False).head(top_n)

        if top_combinations.empty:
            ax.text(0, 0, "No pass combinations found", 
                    ha='center', va='center', fontsize=12, family='monospace',
                    transform=ax.transData)
            continue
            
        # Loop through each top combination and plot with a unique color
        WIDTH_SCALE = 68 / 105
        
        for idx, combo_row in enumerate(top_combinations.itertuples()):
            passer = combo_row.player_name
            receiver = combo_row.receiver_name
            count = combo_row.pass_count
            
            color = colors[idx % len(colors)]
            
            passer_f = format_player_name(passer)
            receiver_f = format_player_name(receiver)
            label = f"{passer_f} → {receiver_f} ({count})"
            
            combo_df = interval_df[
                (interval_df['player_name'] == passer) & 
                (interval_df['receiver_name'] == receiver)
            ].copy()
            
            # Invert y-coordinates for plotting
            combo_df[['y1', 'y2']] *= -1
            
            plotted_label = False
            for _, pass_row in combo_df.iterrows():
                if pd.isna(pass_row['x1']) or pd.isna(pass_row['y1']) or pd.isna(pass_row['x2']) or pd.isna(pass_row['y2']):
                    continue
                
                start_x, start_y = pass_row['x1'], pass_row['y1'] * WIDTH_SCALE
                end_x, end_y = pass_row['x2'], pass_row['y2'] * WIDTH_SCALE
                
                current_label = label if not plotted_label else None
                
                arrow = patches.FancyArrowPatch(
                    (start_x, start_y), (end_x, end_y), arrowstyle='->', mutation_scale=15,
                    color=color, alpha=0.7, linewidth=1.5, label=current_label
                )
                ax.add_patch(arrow)
                plotted_label = True
        
        # Add a legend to each subplot
        ax.legend(loc='upper right', fontsize=9, facecolor='#f4f4f4', framealpha=0.8, edgecolor='black')

    # Add overall title
    fig.suptitle(f'Top {top_n} Correct Pass Combinations for {team_name} (All Attacking Right → Left)', fontsize=24, fontweight='bold')
    
    # Clean up layout and save the single image
    plt.tight_layout(rect=[0, 0, 1, 0.94])
    fig.subplots_adjust(hspace=0.2, wspace=0.1) # Adjust spacing
    
    output_filename = 'soccer_pass_map_all_intervals_GK_FIXED.png'
    plt.savefig(output_filename, dpi=300, bbox_inches='tight', facecolor=fig.get_facecolor())
    print(f"Plot saved successfully as {output_filename}")


# --- Execution block ---
csv_filename = '/Users/gustavoortiz/Downloads/RiestraAlldata.csv' 
team_to_visualize = 'Riestra'
top_n_to_show = 5 

visualize_combined_passes(
    csv_filename,
    team_name=team_to_visualize,
    top_n=top_n_to_show
)
